import java.util.logging.Logger
import Master.{addnode, getSnapShot, loadData, lookupMovie}
import UserActor.{loadMovie, lookMovie}
import akka.actor.{ActorRef, ActorSystem, Props}
import akka.pattern.ask
import akka.util.Timeout
import com.typesafe.config.ConfigFactory
import org.ddahl.rscala.RClient
import scala.collection.mutable
import scala.collection.mutable.ListBuffer
import scala.concurrent.{Await, Future}
import scala.concurrent.duration.DurationInt
import scala.io.Source
import scala.language.postfixOps
object Driver {
  val MAX_SERVERS: Int = ConfigFactory.load("config.conf"  ).getConfig("config").getInt("max_servers")
  val MAX_USERS: Int = ConfigFactory.load("config.conf"  ).getConfig("config").getInt("users")
  val movies = getMovies()
  val r_dist_mean: Int = ConfigFactory.load("config.conf"  ).getConfig("config").getInt("r_dist_mean")
  val r_dist_sd: Int = ConfigFactory.load("config.conf"  ).getConfig("config").getInt("r_dist_standard_deviation")
  val r_dist_size: Int = ConfigFactory.load("config.conf"  ).getConfig("config").getInt("r_dist_size")
  val r_monte_carlo_replicate_size: Int = ConfigFactory.load("config.conf"  ).getConfig("config").getInt("r_monte_carlo_replicate_size")
  //val r_monte_carlo_replicate_size: Int = 4
  def getMovies()  : List[Data] = {
    val resData: ListBuffer[Data] = new ListBuffer[Data]
    val lines = Source.fromResource("data.csv")
    var i: Int = 0
    for (line <- lines.getLines.drop(1)) {
      val cols = line.split(",")
      val data:Data = new Data(i,cols(0))
      resData += data
      i = i + 1
    }
    resData.toList
  }
  val logger:Logger = Logger.getLogger("Actors")
  val actorSystem = ActorSystem("Actors")
  implicit val timeout = Timeout(10 seconds)
  def main(args: Array[String]): Unit = {

    logger.info("starting")
    val serverSupervisor = actorSystem.actorOf(Props(new ServerActor(0,0, actorSystem)), "server-actor-supervisor")
    val master = actorSystem.actorOf(Props(new Master(1, actorSystem)), "master-actor")
    var userCount = 0
    var users:mutable.ListBuffer[ActorRef] = new ListBuffer[ActorRef]()
    (0 to MAX_SERVERS).foreach(i=>{
      users.addOne(actorSystem.actorOf(Props(new UserActor(userCount,userCount,actorSystem)),name = "user-actor-"+userCount))
      userCount +=1
    })
    val R = RClient() // Create instance of R Client
    val num_movies = movies.length
    // An attempt to simulate Monte Carlo Simulation with normal distribution over the number of movies present in the data.csv file with
    // specified mean and standard deviation and replicated over 4 runs and sampled with specified number of samples and with no replacement
    // The values of mean, standard deviation and number of samples & number of replication runs are fetched from configuration
    val monte_carlo_replicate_template = "c <- sample(replicate(n=%d,rnorm(1:%d,mean=%d,sd=%d)),size=%d, replace=FALSE)".format(r_monte_carlo_replicate_size,num_movies,r_dist_mean,r_dist_sd,r_dist_size)
    logger.info(monte_carlo_replicate_template)
    R.eval(monte_carlo_replicate_template)
    logger.info("*******Checking***")
    val values_array = R.evalI1("unique(as.integer(c))") // Array of unique statistically distributed values - ideally need to pass the contents of this array
    // below lookMovie API instead of hard coding int values (like in hw3)

    logger.info("Values generated by R " + values_array.mkString(" "))
    var count = 0
    var userCountVar = 1
    logger.info("-----------------------------------------------------------")
    val future = master ? addnode()
    val result = Await.result(future, timeout.duration)
    logger.info("result :" + result.toString)
    logger.info("-----------------------------------------------------------")
    val future2 = master ? addnode()
    val result2 = Await.result(future2, timeout.duration)
    logger.info("result2 :" + result2.toString)
    logger.info("-----------------------------------------------------------")
    val futuren = master ? addnode()
    val resultn = Await.result(futuren, timeout.duration)
    logger.info("result2 :" + resultn.toString)
    logger.info("-----------------------------------------------------------")
    val future8 = master ? addnode()
    val result8 = Await.result(future8, timeout.duration)
    logger.info("result2 :" + result8.toString)
    logger.info("-----------------------------------------------------------")
    val future3 = users(userCountVar) ? loadMovie(movies(2))
    val result3 = Await.result(future3, timeout.duration)
    logger.info("result3 :" + result3.toString)
    logger.info("-----------------------------------------------------------")
    userCountVar +=1
    val future4 = users(userCountVar) ? loadMovie(movies(3))
    val result4 = Await.result(future4, timeout.duration)
    logger.info("result4 :" + result4.toString)
    userCountVar +=1
    //    logger.info("-----------------------------------------------------------")
    //    val future5 = users(4)  ? lookMovie(movies(3))
    //    val result5 = Await.result(future5, timeout.duration)
    //    logger.info("result5 :" + result5.toString)
    logger.info("-----------------------------------------------------------")
    val future6 = users(userCountVar) ? loadMovie(movies(10))
    val result6 = Await.result(future6, timeout.duration)
    logger.info("result6 :" + result6.toString)
    userCountVar +=1
    //    logger.info("-----------------------------------------------------------")
    //    val future7 = users(5)  ? lookMovie(movies(11))
    //    val result7 = Await.result(future7, timeout.duration)
    //    logger.info("result7 :" + result7.toString)
    //    logger.info("-----------------------------------------------------------")
    val futuresArray = new Array[Future[Any]](values_array.length)
    val resultsArray = new Array[Any](values_array.length)
    for(e <- values_array) {
      futuresArray(count) = users(userCountVar) ? lookMovie(movies(e))
      resultsArray(count) = Await.result(futuresArray(count),timeout.duration)
      logger.info("result" +count+" :" + resultsArray(count).toString)
      logger.info("-----------------------------------------------------------")
      userCountVar +=1
      count +=1
    }

    val future9 = master ! getSnapShot()

    actorSystem.terminate()
  }
}